
#include <memory.h>
#include <string.h>

#include <string>

#include <winsock2.h>    
#include <ws2tcpip.h>    
#include <pcap.h>

#include "arp_ping.h"
#include "packet.h"

using std::string;

#pragma comment (lib,"ws2_32")
#pragma comment (lib,"wpcap")

#pragma warning(disable:4309)
#pragma warning(disable:4305)

#define ETH_PROTO_IP 0x800

#pragma pack(1)

typedef struct {
    unsigned char dest[ETH_ADDRESS_LENGTH];
    unsigned char source[ETH_ADDRESS_LENGTH];
    unsigned short proto;
} eth,*point_eth;

typedef struct iphdr {
    unsigned char verlen;
    unsigned char tos;
    unsigned short total_len;
    unsigned short ident;
    unsigned short frag_and_flags;
    unsigned char ttl;
    unsigned char proto;
    unsigned short checksum;
    unsigned int sourceIP;
    unsigned int destIP;
} IPHDR;

typedef struct {
    unsigned short s_port;
    unsigned short d_port;
    unsigned short length;
    unsigned short cksum;
} udp_hdr;

typedef struct psd_header{
    unsigned int s_ip;
    unsigned int d_ip;
    unsigned char mbz;
    unsigned char proto;
    unsigned short plen;
} psd_header;

typedef struct icmp_hdr {
    unsigned char icmp_type;
    unsigned char icmp_code;
    unsigned short icmp_checksum;
    unsigned short icmp_id;
    unsigned short icmp_sequence;
    unsigned long icmp_timestamp;
} ICMP_HDR,*PICMP_HDR;

#pragma pack(4)

static pcap_t* adapter=NULL;
char local_ip[IPV4_LENGTH]={0};
static SOCKET sock_send=SOCKET_ERROR;
static SOCKET sock_recv=SOCKET_ERROR;

static unsigned short cal_checksum( unsigned short *buf, int size) {
    unsigned long cksum = 0;
    while( size > 1) {
        cksum += *buf++;    
        size -= sizeof( unsigned short);    
    }    
       
    if(size)
        cksum += *( unsigned char *)buf;
    
        
    cksum = ( cksum >> 16) + ( cksum & 0xffff);
    cksum += (cksum >>16);
    return ( unsigned short)(~cksum);    
}
static void get_ip(void) {
    char local_host[64]={0};
    gethostname(local_host,64);
    hostent* host=gethostbyname(local_host);
    char* ip=inet_ntoa(*(in_addr*)host->h_addr_list[0]);
    memcpy(local_ip,ip,strlen(ip));
}
bool packet_init(void) {
    WSADATA WSAData;   
    WSAStartup(MAKEWORD(2, 2), &WSAData);

    sock_send = socket( AF_INET, SOCK_RAW, IPPROTO_IP); 
    BOOL bIphdrIncl = TRUE;
    setsockopt( sock_send, IPPROTO_IP, IP_HDRINCL, (const char *)&bIphdrIncl, sizeof(BOOL));   
    
    sock_recv=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
	int time_out=PACKET_RECV_BLOCK_TIME;
	setsockopt(sock_recv,SOL_SOCKET,SO_RCVTIMEO,(const char*)&time_out,sizeof(time_out));
    sockaddr_in local;
    memset(&local,0,sizeof(local));
    local.sin_family=AF_INET;
    local.sin_port=htons(LOCAL_PORT);
    bind(sock_recv,(const sockaddr*)&local,sizeof(local));

    pcap_if_t *devsin;
    pcap_if_t *d;
    int i=0;
    char errorbuf[PCAP_ERRBUF_SIZE]={0};

    if (pcap_findalldevs(&devsin, errorbuf) == -1)
        return false;

    for(d=devsin, i=0; i< ADAPTER_INDEX-1 ;d=d->next, i++);

    if ((adapter= pcap_open_live(d->name, 65536, 1,1000, errorbuf )) == NULL)
        return false;

    get_ip();
    return true;
}

void packet_clean(void) {
    pcap_close(adapter);
    closesocket(sock_send);
    WSACleanup(); 
}

bool packet_send(const char* targe_ip,const char* packet_buffer,unsigned int packet_length) {
    char packet[PACKET_SEND_BUFFER]={0};
    char buf[PACKET_SEND_BUFFER]={0};
    IPHDR *pIphdr;    
    udp_hdr *pudp_hdr;   

    pIphdr = (IPHDR *)(packet);    
    pIphdr->verlen = 0x45;    
    pIphdr->tos = 0;    
    pIphdr->total_len = htons(sizeof( IPHDR) + sizeof( udp_hdr) + packet_length);    
    pIphdr->ident = htons(0x0000);    
    pIphdr->frag_and_flags = 0x40;    
    pIphdr->ttl = 0x3D;
    pIphdr->proto = IPPROTO_UDP;    
    pIphdr->sourceIP = inet_addr("172.16.1.180");
    pIphdr->destIP = inet_addr(targe_ip);    
    pIphdr->checksum = 0;
           
    pudp_hdr = (udp_hdr*)(packet + sizeof( IPHDR));
    pudp_hdr->s_port=htons(SUPPLICANT_SERVER_PORT);
    pudp_hdr->d_port=htons(SUPPLICANT_SERVER_PORT);
    pudp_hdr->length=htons(sizeof(udp_hdr)+packet_length);
    memcpy((void*)(packet + sizeof( IPHDR) + sizeof( udp_hdr)),(const void*)packet_buffer,packet_length);

    char udp_calcu_cksum_buffer[PACKET_SEND_BUFFER]={0};
    psd_header* ppsd_header=(psd_header*)udp_calcu_cksum_buffer;
    ppsd_header->s_ip=pIphdr->sourceIP;
    ppsd_header->d_ip=pIphdr->destIP;
    ppsd_header->mbz=0;
    ppsd_header->proto=IPPROTO_UDP;
    ppsd_header->plen=htons(packet_length+sizeof(udp_hdr));
    memcpy(&udp_calcu_cksum_buffer[sizeof(psd_header)],(const void*)pudp_hdr,sizeof(udp_hdr));
    memcpy(&udp_calcu_cksum_buffer[sizeof(psd_header)+sizeof(udp_hdr)],(const void*)packet_buffer,packet_length);
    int calcu_length=sizeof(psd_header)+sizeof(udp_hdr)+packet_length;
    pudp_hdr->cksum = cal_checksum( (unsigned short *)udp_calcu_cksum_buffer,calcu_length);

    pIphdr->checksum = cal_checksum( (unsigned short *)packet, sizeof( IPHDR));

    char dest_mac[ETH_ADDRESS_LENGTH]={0};
    char sorc_mac[ETH_ADDRESS_LENGTH]={0};

    if (check_ip_subnet(targe_ip)) {
		arp_ping(targe_ip,dest_mac);
	    memcpy(sorc_mac,gateway_mac,ETH_ADDRESS_LENGTH);
    } else {
		memcpy(dest_mac,gateway_mac,ETH_ADDRESS_LENGTH);
	    memcpy(sorc_mac,local_mac,ETH_ADDRESS_LENGTH);
    }

    point_eth peth=(point_eth)buf;
    memcpy(buf,dest_mac,ETH_ADDRESS_LENGTH);
    memcpy((void*)(buf+ETH_ADDRESS_LENGTH),sorc_mac,ETH_ADDRESS_LENGTH);
    memcpy((void*)(buf+sizeof(eth)),packet,sizeof(IPHDR)+sizeof(udp_hdr)+packet_length);
    peth->proto=htons(ETH_PROTO_IP);

    pcap_sendpacket(adapter,(const unsigned char *) buf,sizeof(eth) + sizeof( IPHDR) + sizeof( udp_hdr) +packet_length);
    return true;
}
bool packet_send_recv(const char* targe_ip,unsigned int targe_port,const char* packet_buffer,unsigned int packet_length) {
    sockaddr_in remote={0};

    remote.sin_addr.S_un.S_addr=inet_addr(targe_ip);
    remote.sin_family=AF_INET;
    remote.sin_port=htons(targe_port);

    if (SOCKET_ERROR!=sendto(sock_recv,packet_buffer,packet_length,0,(const sockaddr*)&remote,sizeof(remote)))
        return true;
    return false;
}
unsigned int packet_recv(char* packet_buffer) {
    char buffer[PACKET_RECV_BUFFER]={0};
    int buffer_length=recvfrom(sock_recv,buffer,PACKET_RECV_BUFFER,0,NULL,NULL);
    if (SOCKET_ERROR!=buffer_length) {
        memcpy(packet_buffer,buffer,buffer_length);
        return buffer_length;
    }
    return -1;
}

bool sniffer_udp_port(const char* targe_ip,unsigned int targe_port) {
    SOCKET sock=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);

	int time_out=SNIFFER_UDP_PORT_TIME;
	setsockopt(sock,SOL_SOCKET,SO_RCVTIMEO,(const char*)&time_out,sizeof(time_out));
    
    sockaddr_in local;
    memset(&local,0,sizeof(local));
    local.sin_family=AF_INET;
    local.sin_port=htons(1234);
    bind(sock_recv,(const sockaddr*)&local,sizeof(local));

    sockaddr_in remote={0};
    remote.sin_addr.S_un.S_addr=inet_addr(targe_ip);
    remote.sin_family=AF_INET;
    remote.sin_port=htons(targe_port);

    sendto(sock,"HELLO!",6,0,(const sockaddr*)&remote,sizeof(remote));

    closesocket(sock);

    DWORD old_tick=GetTickCount();
    DWORD new_tick=old_tick;

    do {
        pcap_pkthdr* header=NULL;
        unsigned char* data=NULL;
        int return_code=pcap_next_ex(adapter,&header,(const unsigned char**)&data);

        if (-1==return_code || 0==return_code) continue;
        IPHDR* pIphdr=(IPHDR*)(data+sizeof(eth));
        if (pIphdr->sourceIP==inet_addr(targe_ip)) {
            if (pIphdr->proto==IPPROTO_ICMP) {
                ICMP_HDR* icmp=(ICMP_HDR*)(data+sizeof(eth)+sizeof(IPHDR));
                if (icmp->icmp_code==3 && icmp->icmp_type==3)
                    return false;
            }
        }
        new_tick=GetTickCount();
    } while ((new_tick-old_tick)<=SNIFFER_UDP_PORT_TIME);

    return true;
}

bool check_ip_subnet(const char* targe_ip) {
	string local(local_ip);
	string remote(targe_ip);

	local=local.substr(0,local.find_last_of("."));
	remote=remote.substr(0,remote.find_last_of("."));

	if (local==remote)
		return true;
	return false;
}
