
#include <memory>

#include <pcap.h>

#include "packet.h"
#include "arp_ping.h"

#define ETH_ADDRESS_LENGTH 6
#define ETH_PROTO_ARP 0x806
#define ETH_TRAILER_LENGTH 0x12

#define IPV4_LENGTH 0x11

#define MAX_ADAPTER_NAME_LENGTH 256
#define MAX_ADAPTER_DESCRIPTION_LENGTH 128
#define MAX_ADAPTER_ADDRESS_LENGTH 8

#pragma pack(1)

typedef struct {
    unsigned char dest[ETH_ADDRESS_LENGTH];
    unsigned char source[ETH_ADDRESS_LENGTH];
    unsigned short proto;
} eth,*point_eth;

typedef struct {
    USHORT    arp_hrd;
    USHORT    arp_pro;
    UCHAR     arp_hln;
    UCHAR     arp_pln;
    USHORT    arp_op;
    UCHAR     arp_sha[6];
    ULONG     arp_spa;
    UCHAR     arp_tha[6];
    ULONG     arp_tpa;
} arp,*point_arp;

#pragma pack(4)

typedef struct {
    char String[4 * 4];
} IP_ADDRESS_STRING, *PIP_ADDRESS_STRING, IP_MASK_STRING, *PIP_MASK_STRING;
 
typedef struct _IP_ADDR_STRING {
    struct _IP_ADDR_STRING* Next;
    IP_ADDRESS_STRING IpAddress;
    IP_MASK_STRING IpMask;
    DWORD Context;
} IP_ADDR_STRING, *PIP_ADDR_STRING;

typedef struct _IP_ADAPTER_INFO {  
  struct _IP_ADAPTER_INFO *Next;
  DWORD ComboIndex;  
  char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];
  char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];
  UINT AddressLength;  
  BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];
  DWORD Index;
  UINT Type;  
  UINT DhcpEnabled;
  PIP_ADDR_STRING CurrentIpAddress;
  IP_ADDR_STRING IpAddressList;
  IP_ADDR_STRING GatewayList;
  IP_ADDR_STRING DhcpServer;
  BOOL HaveWins;
  IP_ADDR_STRING PrimaryWinsServer;
  IP_ADDR_STRING SecondaryWinsServer;
  time_t LeaseObtained;
  time_t LeaseExpires;
} IP_ADAPTER_INFO,  *PIP_ADAPTER_INFO;

typedef DWORD (__stdcall *_GetAdaptersInfo)(PIP_ADAPTER_INFO,PULONG);

static pcap_t* adapter=NULL;
static char gateway_ip[IPV4_LENGTH]={0};
char gateway_mac[ETH_ADDRESS_LENGTH]={0};
char local_mac[ETH_ADDRESS_LENGTH]={0};

bool arp_ping_init(void) {
    char buffer[64]={0};
    pcap_if_t *devsin;
    pcap_if_t *d;
    int i=0;
    char errorbuf[PCAP_ERRBUF_SIZE]={0};

    if (pcap_findalldevs(&devsin, errorbuf) == -1)
        return false;

    for(d=devsin, i=0; i< ADAPTER_INDEX-1 ;d=d->next, i++);

    if ((adapter= pcap_open_live(d->name, 65536, 1,1000, errorbuf )) == NULL)
        return false;

	HMODULE dll_iphlpapi=NULL;
    dll_iphlpapi=LoadLibrary("iphlpapi.dll");
    _GetAdaptersInfo GetAdaptersInfo_=(_GetAdaptersInfo)GetProcAddress(dll_iphlpapi,"GetAdaptersInfo");

	IP_ADAPTER_INFO local_network_data;
	unsigned long output_local_network_data_length=sizeof(local_network_data);
    DWORD return_code=GetAdaptersInfo_(&local_network_data,&output_local_network_data_length);

	if (ERROR_BUFFER_OVERFLOW==return_code) {
		return_code=GetAdaptersInfo_(&local_network_data,&output_local_network_data_length);
	}
	if (NO_ERROR==return_code) {
		memcpy(local_mac,&local_network_data.Address,ETH_ADDRESS_LENGTH);
		memcpy(gateway_ip,&local_network_data.GatewayList.IpAddress,IPV4_LENGTH-1);
		arp_ping(gateway_ip,gateway_mac);
		return true;
	}

	return false;
}

void arp_ping_clean(void) {
    pcap_close(adapter);
}

bool arp_ping(const char* targe_ip,char* output_mac) {
	char send_packet[ARP_PING_SEND_BUFFER_LENGTH]={0};

	point_eth peth=(point_eth)send_packet;
	peth->dest[0]=0xFF;
	peth->dest[1]=0xFF;
	peth->dest[2]=0xFF;
	peth->dest[3]=0xFF;
	peth->dest[4]=0xFF;
	peth->dest[5]=0xFF;
	memcpy(&peth->source,local_mac,ETH_ADDRESS_LENGTH);
	peth->proto=htons(ETH_PROTO_ARP);

	point_arp parp=(point_arp)(send_packet+sizeof(eth));
	parp->arp_hrd=htons(0x0001);
	parp->arp_pro=htons(0x0800);
	parp->arp_hln=0x6;
	parp->arp_pln=0x4;
	parp->arp_op=htons(0x0001);
	memcpy(&parp->arp_sha,local_mac,ETH_ADDRESS_LENGTH);
	parp->arp_spa=inet_addr(local_ip);
	parp->arp_tha[0]=0x00;
	parp->arp_tha[1]=0x00;
	parp->arp_tha[2]=0x00;
	parp->arp_tha[3]=0x00;
	parp->arp_tha[4]=0x00;
	parp->arp_tha[5]=0x00;
	parp->arp_tpa=inet_addr(targe_ip);

	char* eth_trailer=(char*)(send_packet+sizeof(eth)+sizeof(arp));
	for (int i=0;i<ETH_TRAILER_LENGTH;++i,++eth_trailer)
		*eth_trailer=0x11;

    pcap_sendpacket(adapter,(const unsigned char *)send_packet,sizeof(eth)+sizeof(arp)+ETH_TRAILER_LENGTH);

    DWORD old_tick=GetTickCount();
    DWORD new_tick=old_tick;

    do {
        pcap_pkthdr* header=NULL;
        unsigned char* data=NULL;
        int return_code=pcap_next_ex(adapter,&header,(const unsigned char**)&data);

        if (-1==return_code || 0==return_code) continue;
        parp=(point_arp)(data+sizeof(eth));
        if (parp->arp_spa==inet_addr(targe_ip)) {
			memcpy(output_mac,parp->arp_sha,ETH_ADDRESS_LENGTH);
			return true;
        }
        new_tick=GetTickCount();
    } while ((new_tick-old_tick)<=ARP_PING_WAIT_TIME);
	
	return false;
}
